#!/usr/bin/env bash

# colors
if [[ $(tput colors) -ge 256 ]]; then
    RED=$(tput setaf 196)
    GREEN=$(tput setaf 46)
    YELLOW=$(tput setaf 226)
    CYAN=$(tput setaf 51)
else
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    CYAN=$(tput setaf 6)
fi
NO_COLOR=$(tput sgr0)
BOLD=$(tput bold)

green() {
  printf "${GREEN}%s${NO_COLOR}" "$1"
}

red() {
  printf "${RED}%s${NO_COLOR}" "$1"
}

yellow() {
  printf "${YELLOW}%s${NO_COLOR}" "$1"
}

cyan() {
  printf "${CYAN}%s${NO_COLOR}" "$1"
}

error() {
  printf "$(red '[ERROR]') %s\n" "$1"
}

info() {
  printf "$(cyan '[INFO]') %s\n" "$1"
}

success() {
  printf "$(green '[SUCCESS]') %s\n" "$1"
}

warn() {
  printf "$(yellow '[WARN]') %s\n" "$1"
}

is_non_zero_string() {
  test -n "${1}"
}

is_file() {
  is_non_zero_string "${1}" && test -f "${1}"
}

is_executable() {
  test -e "${1}" && test -x "${1}"
}

is_directory() {
  is_non_zero_string "${1}" && test -d "${1}"
}

is_git_repo() {
  is_directory "${1}" && test -d "${1}/.git"
}

load_file_if_exists() {
  is_file "${1}" && source "${1}" || true
}

delete_directory_if_exists() {
  is_directory "${1}" && warn "$(red 'Deleting') ${1}" && sudo rm -rf "${1}"
}

command_exists() {
  type "${1}" &> /dev/null 2>&1
}

is_macos() {
  [[ "${OSTYPE}" =~ ^darwin ]]
}

is_linux() {
  [[ "${OSTYPE}" =~ ^linux-gnu ]]
}

is_windows() {
  [[ "${OSTYPE}" =~ ^(msys|cygwin)$ ]]
}

# path functions
path_add() {
  local directory="${1}"
  local direction="${2:-after}"

  if ! is_non_zero_string "${directory}" || [[ "${directory}" == *:* ]]; then
    echo "path_add: invalid argument: '$directory'" >&2
    return 1
  fi

  case "${direction}" in
    after) PATH="${PATH}:${directory}";;
    *) PATH="${directory}:${PATH}";;
  esac

  export PATH
}

path_remove() {
  local directory=$1

  if ! is_non_zero_string "${directory}" || [[ "${directory}" == *:* ]]; then
    echo "path_remove: invalid argument: '$directory'" >&2
    return 1
  fi

  PATH=$(echo "$PATH" | tr ':' '\n' | grep -v "^$directory$" | tr '\n' ':')
  PATH="${PATH%:}"

  export PATH
}

path_clean() {
  local loc
  declare -A seen
  local newarr=()

  for loc in $(echo ${PATH} | tr ':' '\n'); do
    if ! is_non_zero_string "${loc}" || [[ ${loc:0:1} != '/' ]] || is_non_zero_string "${seen[${loc}]}" ; then
      continue
    fi
    if ! is_directory "${loc}" || ! is_executable "${loc}" ; then
      continue
    fi
    seen["${loc}"]=1
    newarr+=("${loc}")
  done

  PATH=$(IFS=:; echo "${newarr[*]}")
  export PATH
}

function timeshell() {
  shell=${1-$SHELL}
  for i in $(seq 1 10); do /usr/bin/time $shell -i -c exit; done
}

if is_macos; then
  reinstall_xcode() {
    delete_directory_if_exists "/Applications/Xcode.app"

    xcode-select --install
    sudo xcodebuild -license accept || true
  }

  reinstall_xcode_cmdline_tools() {
    delete_directory_if_exists "/Library/Developer/CommandLineTools"

    touch /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
    softwareupdate -ia
    rm /tmp/.com.apple.dt.CommandLineTools.installondemand.in-progress
  }
fi

if [[ "${SHELL}" == */bash ]]; then
  load_bash_configs() {
    file_list=('.bash_profile' '.bashrc' '.bash_aliases', '.bashrc.local', '.bash_completion')
    for file in "${file_list[@]}"; do
      load_file_if_exists "${HOME}/${file}"
    done
  }
elif [[ "${SHELL}" == */zsh ]]; then
  function load_zsh_configs() {
    load_file_if_exists "${HOME}/.zshenv"
    echo "${ZDOTDIR}"
    config_files=('.zprofile' '.zshrc')
    for file in "${config_files[@]}"; do
      load_file_if_exists "${ZDOTDIR}/${file}"
    done
  }
fi

if is_linux; then
  SKIP_CONFIRMATION=${SKIP_CONFIRMATION:-false}
  INSTALL_K3S=${INSTALL_K3S:-true}
  INSTALL_FZF=${INSTALL_FZF:-true}

  manage_apt_packages() {
    info "üì¶ Checking for APT updates and installing from .packages"

    info "üîç Updating package list..."
    sudo apt-get update -qq

    info "üìã Checking for upgradable packages..."
    UPGRADABLE=$(apt list --upgradable 2>/dev/null | grep -v "Listing" || true)

    if is_non_zero_string "$UPGRADABLE"; then
      info "üîÑ Upgradable packages detected:"
      echo "$UPGRADABLE" | awk '{print "  ‚¨ÜÔ∏è " $1}'
      if _confirm_action "‚ö†Ô∏è  Do you want to upgrade all packages?"; then
        sudo apt-get upgrade -y
      else
        warn "‚è≠Ô∏è  Skipped upgrade"
      fi
    else
      success "‚úÖ All packages are up to date"
    fi

    if is_file "${HOME}/.packages"; then
      info "üì¶ Ensuring required packages from .packages are installed..."
      xargs -a "${HOME}/.packages" sudo apt-get install -y -q
    else
      warn "‚ö†Ô∏è  No .packages file found at ${HOME}/.packages"
    fi
  }

  install_or_update_k3s() {
    if ! _verify_binary_update "k3s" INSTALL_K3S "k3s-io/k3s" "k3s --version | head -n1 | awk '{print \$3}'"; then
      return
    fi

    local latest="$BINARY_LATEST_VERSION"

    if _confirm_action "‚ö†Ô∏è  Proceed to install/update k3s $latest?"; then
      curl -sfL https://get.k3s.io | INSTALL_K3S_VERSION="$latest" K3S_KUBECONFIG_MODE=644 sh -s - --disable traefik --disable servicelb || {
        error "‚ùå Failed to install/update k3s"
        return
      }
      success "‚úÖ k3s installed/updated to version $latest"
    else
      warn "‚è≠Ô∏è  Skipped k3s install/update"
    fi
  }

  install_or_update_fzf() {
    if ! _verify_binary_update "fzf" INSTALL_FZF "junegunn/fzf" "fzf --version | awk '{print \"v\"\$1}'"; then
      return
    fi

    local latest="$BINARY_LATEST_VERSION"

    if _confirm_action "‚ö†Ô∏è  Proceed to install/update fzf $latest?"; then
      cwd=$(pwd)
      cd "${TMPDIR:-/tmp}" || exit 1
      destination="${HOME}/bin/fzf"
      arch=$(dpkg --print-architecture)
      os_type=$(uname | tr '[:upper:]' '[:lower:]')
      url="https://github.com/junegunn/fzf/releases/download/${latest}/fzf-${latest#v}-${os_type}_${arch}.tar.gz"
      info "‚¨áÔ∏è Downloading fzf from $url..."
      (curl -fsL "$url" | tar -xz) || { error "‚ùå Failed to download fzf"; return; }
      mv fzf "$destination"
      chmod +x "$destination"
      cd "$cwd"
      success "‚úÖ fzf is now at version $latest"
    else
      warn "‚è≠Ô∏è  Skipped fzf install/update"
    fi
  }

  _confirm_action() {
    local prompt="$1"
    if [[ "$SKIP_CONFIRMATION" == true ]]; then
      return 0
    fi
    read "confirm?$prompt [y/N]: "
    [[ "$confirm" =~ ^[Yy]$ ]]
  }

  _verify_binary_update() {
    local binary_name="$1"
    local install_flag_name="$2"
    local install_flag_value
    eval "install_flag_value=\${$install_flag_name}"
    local repo="$3"
    local current_version_fetch_cmd="$4"

    [[ "$install_flag_value" != true ]] && {
      warn "‚ö†Ô∏è  Skipping $binary_name installation (${install_flag_name}=${install_flag_value})"
      return 1
    }

    local latest
    latest=$(curl -fsSL "https://api.github.com/repos/${repo}/releases/latest" |
            grep -oE '"tag_name"\s*:\s*"[^"]+"' |
            sed -E 's/^"tag_name"\s*:\s*"([^"]+)"$/\1/' |
            grep -E '[0-9]+\.[0-9]+\.[0-9]+')

    [[ -z "$latest" ]] && {
      error "‚ùå Failed to fetch latest $binary_name version"
      return 1
    }

    if command_exists "$binary_name"; then
      local current
      current=$(eval "$current_version_fetch_cmd")
      if [[ "$current" == "$latest" ]]; then
        success "‚úÖ $binary_name is up to date ($current)"
        return 1
      else
        info "üîÑ Updating $binary_name: $current ‚Üí $latest"
      fi
    else
      info "‚¨áÔ∏è Installing $binary_name $latest"
    fi

    export BINARY_LATEST_VERSION="$latest"
    return 0
  }
fi
